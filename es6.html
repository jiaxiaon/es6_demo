<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>

</html>

<script>
    // var arr = [1,[[2,3],4],5];
    // arr.map((value,key)=>{
    //     console.log(value,key)
    // })
    // arr.forEach((value,key)=>{
    //     console.log(value,key)
    // })
    // let {a,b} = {a:1};
    // console.log(a,b)
    // let {a,b = 2} = {a:1};
    // console.log(a,b)
    // let json = {
    //     0:1,
    //     1:2,
    //     length:2,
    // }
    // let arr = Array.from(json);
    // console.log(arr)
    // new Set()转化出来的是一个json对象
    // let arr = [1,'1','a','a','a',2,.0,null,undefined,undefined,null];
    // console.log(new Set(arr),Array.from(new Set(arr)))
    // let arr = Array.from([1, 2, 3], (value,key) => {
    //     console.log(value,key);
    //     return value * value;
    // });
    // console.log(arr)

    // const json = {
    //     a:{
    //         0:1,
    //         1:5,
    //     },
    //     b(){
    //         setTimeout(()=>{
    //             let arr = Array.from([this.a,1],(value,key)=>{
    //                 return value;
    //             });
    //             console.log(arr)
    //         },100)
    //     }
    // }
    // json.b();

    // let arr = [1,5,13,2,564,1,64];   // find方法类似于filter,不过filter会生成新的数组，find只是找到对应的值
    // let a = arr.find((value,key,arr)=>{
    //     return (value*10 == 50);
    // })
    // let a = arr.filter((value,key,arr)=>{
    //     return (value * 10 == 50)
    // })
    // console.log(arr,a);

    // let arr = ['a','b','c']; // fill方法不会补充新的元素，只会抹去已有的元素
    // arr.fill('d',2,4);
    // console.log(arr);

    // function fetch(url, { body = {}, method = 'GET', headers = {} } = {}) { // 函数参数可以与结构赋值结合使用
    //     console.log(method);
    // }
    // function fetchTest(url, { body = {}, method = 'GET', headers = {} }) {
    //     console.log(body,method);
    // }
    // fetch('a');
    // fetchTest('a',{method:"POST"}); // 此时不传入第二个参数会报错

    // var x = 1;
    // function foo(x, y = function () { x = 2; console.log(x)/* 2 */}) {
    //     console.log(x); // undefined
    //     x = 3;
    //     console.log(x); // 3
    //     y();
    //     console.log(x); // 2
    // }
    // console.log(x);
    // foo() // 2

    // var x = 1;
    // function foo (x , y = function () { x = 2; console.log(x)}) {
    //     console.log(x);
    //     var x = 3;
    //     y();
    //     console.log(x);
    // }
    // console.log(x);
    // foo(x);



    // let foo = 'outer';
    // function bar(func = (x) => foo){
    //     let foo = 'inner';
    //     console.log(func());
    // }
    // bar(tab({a:1,b:2},'a',3));
    // function bar(func = () => tab(11)){
    //     let foo = 'inner';
    //     console.log(func());
    // }
    // function tab (...arr) {
    //     console.log(arr)
    // }
    // bar();

    // const str = `abacas123321`;
    // const arr = [...str,1,2,1];
    // const newArr = Array.from(new Set(arr));
    // console.log(arr,newArr)


    // const a = {
    //     toString(){
    //         return 'def';
    //     },
    // };
    // const a = {
    //     c(){ // 这个时候c函数返回和上边返回的值不一样
    //         return 'def';
    //     },
    // };
    // const s1 = Symbol(a);
    // const s2 = Symbol('b');
    // console.log(s1,s2);

    // const arr = [1,1,1,1,1,null,1,1,1,,1,1,2,5,null,undefined,undefined,,];
    // const arr1 = [2,1,5,null,1];
    // var s = new Set([...arr]);
    // s.add(arr); // 添加某个值
    // s.add(arr1);
    // s.delete(10); // 删除某个值，这个值必须在set对象中
    // s.has(5); // 这个返回一个布尔值，判断当前值是否在set对象中
    // s.clear(); // 这个方法清除掉set对象
    // console.log(s,s.size,s.has(5));

    /**/

    /*  
        Set结构的实例有四个遍历方法，可以用于遍历成员。
        keys()：返回键名的遍历器
        values()：返回键值的遍历器
        entries()：返回键值对的遍历器
        forEach()：使用回调函数遍历每个成员 
    */
    // function a(){
    //     return 'red';
    // }
    // class testSet {
    //     constructor (type = 'array') {
    //         this.state={
    //             type
    //         };
    //     }
    //     a () {
    //         return this.state.type;
    //     }
    // }
    // const testNewSet = new testSet({type:'object'});
    // const testobject = new testSet({});
    // const testNormal = new testSet();
    // const testNormal1 = new testSet();
    // // set对class类进行去重时每个class类都是单独的,但是如果直接调用方法，方法返回的值一样时，则会去重
    // let set = new Set(['red',1,null,undefined,a(),NaN,NaN,testNewSet.a(),testobject.a(),testNormal.a(),testNormal1.a(),testNewSet,testobject,testNormal,testNormal1])
    // console.log([...set])
    // for(let item of set.keys()){ // keys方法与values方法返回的值都是set对象中的元素
    //     console.log(item);
    // }
    // for(let item of set.values()){
    //     console.log(item);
    // }
    // for(let item of set.entries()){ // 返回一个数组，包含set对象的键值与键名
    //     console.log(item);
    // }

    /**/

    // let arr = [1,2,3,4,4,2];
    // let set = new Set([...arr].map(x => { // map循环
    //     return x+1;
    // })); /* 这个时候返回一个{} */
    // let set = new Set([...arr].filter(x => { // es6过滤
    //     return x-1 == 2 || x-2 ==2;
    // })) /* 返回{} */
    // console.log(set);
    // let a = new Set([1, 2, 3]);
    // let b = new Set([4, 3, 2]);

    /**/

    // // 并集:两个集合合并
    // let union = new Set([...a, ...b]);
    // // Set {1, 2, 3, 4}

    // // 交集:两个集合相交的元素
    // let intersect = new Set([...a].filter(x => b.has(x)));
    // // set {2, 3}

    // // 差集:两个集合A与B，A中有的，B中没有
    // let difference = new Set([...a].filter(x => !b.has(x)));
    // // Set {1}

    /**/

    // const m = new Map();
    // let o = {
    //     p: 'Hellow'
    // }
    // m.set(o, 'content');
    // m.set('o', 'content');
    // console.log(typeof m,m);


    /* promise */
    // var promise = new Promise(function (resolve, reject) {
    //     if ('a'/* 异步操作成功 */) {
    //         resolve();
    //         console.log('success')
    //     } else {
    //         reject();
    //         throw console.error('fail');
    //     }
    // });
    // promise.then((res)=>{
    //     console.log(res)
    // })

    // function timeout(ms){
    //     return new Promise((resolve, reject) => {
    //         setTimeout(resolve, ms, 'done');
    //     })
    // }
    // timeout(1000).then((res) => {
    //     console.log(res);
    // })

    // let promise_state = false;
    // const p1 = new Promise(function (resolve, reject) {
    //     setTimeout(() => {
    //         if(promise_state){
    //             return resolve();
    //         }
    //         reject(new Error('fail'))
    //     }, 3000);
    // })
    // const p2 = new Promise(function (resolve, reject) {
    //     setTimeout(() => {
    //         resolve(p1);
    //         console.log('执行了第二个Promise');
    //     }, 0)
    // })
    // p2
    // .then((res) => {
    //     console.log(res)
    // })
    // .catch(res => console.log(res))

    // var getPromise = function (data) {
    //     return new Promise(function(resolve, reject){
    //         if(data.state){
    //             resolve(data);
    //         }else{
    //             reject(new Error(data.failText));
    //         }
    //     })
    // }
    // const data = {
    //     state:false,
    //     a:1,
    //     methods(){
    //         console.log(`我是被执行的函数${this.a}`)
    //     },
    //     failText:'执行失败了'
    // }
    // getPromise(data)
    // .then(res=>{
    //     res.methods();
    //     res.methods1(); // 当.then函数有地方执行失败的时候会自动转到.catch函数中
    // })
    // .catch(res=>{
    //     console.log(res);
    // })

    // const someAsyncThing = function () {
    //     return new Promise(function (resolve, reject) {
    //         try {
    //             resolve(x + 2);
    //         } catch (res) {
    //             reject(new Error(res.message));
    //         }
    //     })
    // }
    // someAsyncThing()
    // .then(() => {
    //     console.log('everything is great');
    // })
    // .catch((res) => {
    //     console.log(res);
    // })

    // const data = {
    //     success: true,
    //     methods:{
    //         cdName:'社会摇',
    //         successFunc(){
    //             console.log(this.cdName);
    //         }
    //     },
    // }
    // var p1 = function (data = {}) {
    //     return　new Promise((resolve, reject) => {
    //         if(data.success){
    //             resolve(data);
    //         }else{
    //             reject('p1已经失败了');
    //         }
    //     })
    // }
    // var p2 = function () {
    //     return new Promise((resolve, reject) => {
    //         // reject('a');
    //         resolve('success');
    //     })
    // }
    // Promise.all([p1(data),p2()])  /* all方法会把所有的执行一遍，只要有一个reject，就会终止，否则等全部resolve */
    // .then(res=>{
    //     res[0].methods.successFunc();
    // })
    // .catch(res => console.log(res))
    /* Promise.race()方法只要其中有一个状态改变就会终止 */



    /* */
    // function* hello(){
    //     // let a = true;
    //     // if(a){
    //     //     return 'ending----state';
    //     // }
    //     yield 'hello';
    //     yield 'word';    // yiled不能直接写在方法中
    //     return 'ending';
    // }
    // const hw = hello(); // 直接调用方法是不会返回值的，需要next方法，遇到yield暂停并且返回值，遇到return则直接返回后边不继续执行
    // console.log(hw.next());

    // function * f(){
    //     yield 'hello';
    //     console.log('执行');
    //     yield 'word';
    //     return 'ending';
    // }
    // var a = f();
    // console.log(a.next(),a.next());

    // function* foo(x) {
    //     console.log(x);
    //     var y = 2 * (yield (x + 1));
    //     console.log(y)
    //     var z = yield (y / 3);
    //     console.log(z)
    //     return (x + y + z);
    // }
    // var a = foo(5);
    // console.log(a.next());
    // console.log(a.next(12));
    // console.log(a.next(30));


    /* ------------------------------------------------------ */
    // var obj = new Proxy({}, {
    //     get: function (target, key, receiver) {
    //         console.log(`getting ${key}!`,target, key, receiver);
    //         return Reflect.get(target, key, receiver);
    //     },
    //     set: function (target, key, value, receiver) {
    //         console.log(`setting ${key}!`,target, key, value, receiver);
    //         return Reflect.set(target, key, value, receiver);
    //     }
    // });
    // obj.count = 1;
    // obj.count++;


    let name = 'xx';
    let age = 9;
    function tag(strArr, ...args) {
        var str = '';
        for (let i = 0; i < args.length; i++) {
            str += strArr[i] + args[i]
        }
        console.log(strArr, args);
        //[ '', '今年', '岁了' ]   [ 'xx', 9 ]
        //
        str += strArr[strArr.length - 1];
        return str;
    }
    let str = tag`${name}今年${age}岁了`;
    console.log(str);
</script>